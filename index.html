<!DOCTYPE html>
<html lang="ko">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>다중 모드 템플릿 매칭 테스트</title>
    <style>
        body {
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            line-height: 1.6;
            margin: 0;
            padding: 20px;
            background-color: #f5f5f5;
        }
        .container {
            max-width: 800px;
            margin: 0 auto;
            background-color: white;
            padding: 20px;
            border-radius: 8px;
            box-shadow: 0 2px 10px rgba(0, 0, 0, 0.1);
        }
        h1 {
            color: #333;
            border-bottom: 2px solid #eee;
            padding-bottom: 10px;
        }
        button {
            background-color: #4CAF50;
            color: white;
            border: none;
            padding: 10px 15px;
            text-align: center;
            font-size: 16px;
            margin: 10px 0;
            cursor: pointer;
            border-radius: 4px;
        }
        button:hover {
            background-color: #45a049;
        }
        button:disabled {
            background-color: #cccccc;
            cursor: not-allowed;
        }
        .status {
            margin: 10px 0;
            padding: 10px;
            background-color: #f0f0f0;
            border-left: 4px solid #2196F3;
        }
        .error {
            background-color: #ffebee;
            border-left: 4px solid #f44336;
        }
        .success {
            background-color: #e8f5e9;
            border-left: 4px solid #4CAF50;
        }
        .result-container {
            margin-top: 20px;
        }
        .loading {
            display: inline-block;
            margin-left: 10px;
            color: #666;
        }
        .mode-selector {
            margin: 15px 0;
            padding: 10px;
            background-color: #f9f9f9;
            border-radius: 4px;
            border: 1px solid #ddd;
        }
        .mode-selector label {
            margin-right: 15px;
            cursor: pointer;
            display: inline-flex;
            align-items: center;
        }
        .mode-selector input[type="radio"] {
            margin-right: 5px;
        }
        .info-box {
            margin-top: 15px;
            padding: 10px;
            background-color: #e3f2fd;
            border-left: 4px solid #2196F3;
            font-size: 14px;
        }
        .tabs {
            display: flex;
            margin-bottom: 15px;
            border-bottom: 1px solid #ddd;
        }
        .tab {
            padding: 8px 15px;
            background-color: #f1f1f1;
            border: 1px solid #ddd;
            border-bottom: none;
            margin-right: 5px;
            border-radius: 4px 4px 0 0;
            cursor: pointer;
        }
        .tab.active {
            background-color: white;
            border-bottom: 1px solid white;
            margin-bottom: -1px;
            font-weight: bold;
        }
    </style>
</head>
<body>
    <div class="container">
        <h1>다중 모드 템플릿 매칭 테스트</h1>
        
        <div id="status" class="status">
            OpenCV.js 로드 대기 중... 초기화 버튼을 클릭하세요.
        </div>
        
        <button id="initButton">모듈 초기화</button>

        <div id="modeSelector" class="mode-selector" style="display:none;">
            <h3>매칭 모드 선택</h3>
            <div>
                <label>
                    <input type="radio" name="matchMode" value="default" checked> 신청자 목록
                </label>
                <label>
                    <input type="radio" name="matchMode" value="mode1"> 공대원 목록
                </label>
            </div>
            <div class="info-box">
                <p><strong>모드 설명:</strong></p>
                <ul>
                    <li><strong>신청자 목록:</strong> 템플릿 매칭 후 신청자 목록 영역을 크롭합니다.</li>
                    <li><strong>공대원 목록:</strong> 템플릿 매칭 후 공대원 목록 영역을 크롭합니다.</li>
                </ul>
            </div>
        </div>
        
        <button id="captureButton" disabled>클립보드 이미지 분석</button>

        <div id="charRecognitionSection" style="display:none; margin-top: 20px; padding: 15px; background-color: #f9f9f9; border-radius: 4px; border: 1px solid #ddd;">
            <h3>문자 인식 테스트</h3>
            
            <div class="info-box">
                <p>크롭된 이미지에서 문자 템플릿 매칭을 수행합니다. 진행하기 전에 먼저 이미지를 크롭해야 합니다.</p>
            </div>
            
            <div id="templateLoadingStatus" class="status" style="display:none;"></div>
            
            <div style="margin: 15px 0;">
                <label>매칭 임계값: 
                    <input type="range" id="thresholdSlider" min="0" max="100" value="70" style="vertical-align: middle;">
                    <span id="thresholdValue">0.7</span>
                </label>
            </div>
            
            <button id="loadTemplatesButton" disabled>문자 템플릿 로드</button>
            <button id="recognizeButton" disabled>문자 인식 실행</button>
        </div>

        <div id="recognitionResultContainer" class="result-container" style="display:none;"></div>

        <div id="resultTabs" class="tabs" style="display:none;">
            <div class="tab active" data-target="latestResult">최근 결과</div>
            <div class="tab" data-target="modeComparison">모드 비교</div>
        </div>
        
        <div id="resultContainer" class="result-container"></div>
        <div id="comparisonContainer" class="result-container" style="display:none;"></div>

        <div class="mode-selector" style="display:none; margin-top: 15px;">
            <label style="display: flex; align-items: center;">
                <input type="checkbox" id="wasmToggle" style="margin-right: 8px;">
                WebAssembly 엔진 사용 (성능 향상)
            </label>
        </div>

        <div id="performanceResult" style="display:none; margin-top: 10px;"></div>
    </div>
    
    <script type="module">
        import OpenCVTemplateImageCropper from './template-match.js';
        import WasmTemplateMatcher from './wasm-src/wasm-template-matcher.js';
        
        // WASM 템플릿 매처 인스턴스 (글로벌 변수)
        let wasmMatcher = null;
        let useWasm = false; // WASM 사용 여부 토글
        let indexer = null; // 추가: 템플릿 인덱서
        let parallelMatcher = null; // 추가: 병렬 매칭 처리기

        // 문자 템플릿 사전 인덱싱 시스템
        class TemplateIndexer {
            constructor() {
                this.index = {}; // 특징값 -> 템플릿ID 매핑
                this.templates = {};
            }
            
            // 모든 템플릿 인덱싱 (한번만 실행)
            buildIndex(templates) {
                if (!templates || Object.keys(templates).length === 0) {
                    console.error('템플릿이 없습니다');
                    return;
                }
                
                this.templates = templates;
                console.log(`${Object.keys(templates).length}개 템플릿 인덱싱 시작...`);
                
                // 처리할 템플릿 수 제한 (성능 개선을 위해)
                const templateIds = Object.keys(templates); // 최대 500개로 제한
                
                // 모든 템플릿을 특징 기반으로 인덱싱
                for (const id of templateIds) {
                    const template = templates[id];
                    // 간단한 특징 추출
                    const features = this.extractSimpleFeatures(template.image);
                    
                    // 추출된 각 특징을 버킷으로 변환하여 인덱스에 추가
                    for (const feature of features) {
                        const bucket = this.quantizeFeature(feature);
                        if (!this.index[bucket]) this.index[bucket] = [];
                        this.index[bucket].push(id);
                    }
                }
                
                console.log(`인덱싱 완료: ${Object.keys(this.index).length} 버킷 생성`);
            }
            
            // 간단한 특징 추출 (매우 빠른 계산)
            extractSimpleFeatures(image) {
                if (!image) return Array(16).fill(0);
                
                try {
                    const features = [];
                    
                    if (image instanceof HTMLImageElement || image instanceof HTMLCanvasElement) {
                        const canvas = document.createElement('canvas');
                        const ctx = canvas.getContext('2d', {willReadFrequently: true});
                        canvas.width = image.width || image.naturalWidth || 16;
                        canvas.height = image.height || image.naturalHeight || 16;
                        ctx.drawImage(image, 0, 0, canvas.width, canvas.height);
                        
                        // 4x4 그리드로 나누어 더 정밀한 특징 추출
                        const cellWidth = Math.floor(canvas.width / 4);
                        const cellHeight = Math.floor(canvas.height / 4);
                        
                        // 16개의 셀에서 특징 추출
                        for (let y = 0; y < 4; y++) {
                            for (let x = 0; x < 4; x++) {
                                features.push(this.calculateAvgBrightness(
                                    ctx, 
                                    x * cellWidth, 
                                    y * cellHeight, 
                                    (x+1) * cellWidth, 
                                    (y+1) * cellHeight
                                ));
                            }
                        }
                    } else {
                        // 기본값 (16개 특징)
                        return Array(16).fill(0.5);
                    }
                    
                    return features;
                } catch (e) {
                    console.error('특징 추출 오류:', e);
                    return Array(16).fill(0);
                }
            }
            
            // 영역의 평균 밝기 계산
            calculateAvgBrightness(ctx, x1, y1, x2, y2) {
                const imageData = ctx.getImageData(x1, y1, x2 - x1, y2 - y1);
                let sum = 0;
                for (let i = 0; i < imageData.data.length; i += 4) {
                    // 간단한 그레이스케일 변환 (R+G+B)/3
                    sum += (imageData.data[i] + imageData.data[i+1] + imageData.data[i+2]) / 3;
                }
                return sum / (imageData.data.length / 4) / 255; // 0~1 사이 값으로 정규화
            }
            
            // 특징값을 버킷으로 양자화
            quantizeFeature(value) {
                // 기존: 0.1 단위로 10개 버킷 생성
                // 개선: 0.05 단위로 20개 버킷 생성
                return Math.round(value * 20) / 20;
            }
            
            // 이미지 매칭 - 인덱스를 사용해 매우 빠르게 후보 추출
            findCandidates(queryImage) {
                // 쿼리 이미지에서 동일한 특징 추출
                const features = this.extractSimpleFeatures(queryImage);
                console.log("추출된 이미지 특징:", features);
                
                // 특징값으로 후보 템플릿 검색
                const candidateIds = new Set();
                
                // 각 특징에 대해 버킷 검색
                for (const feature of features) {
                    const bucket = this.quantizeFeature(feature);
                    const tolerance = 0.2; // 오차 허용 범위 증가 (0.1 -> 0.2)
                    
                    // 해당 버킷과 인접 버킷 검색
                    for (let delta = -tolerance; delta <= tolerance; delta += tolerance/2) { // 더 세밀한 증분
                        const nearBucket = this.quantizeFeature(feature + delta);
                        if (this.index[nearBucket]) {
                            this.index[nearBucket].forEach(id => candidateIds.add(id));
                        }
                    }
                }
                
                // 후보가 너무 적으면 모든 템플릿의 최대 200개를 사용
                const ids = Array.from(candidateIds);
                if (ids.length < 10 && Object.keys(this.templates).length > 0) {
                    console.log("후보가 적어 기본 템플릿 사용");
                    // 200개의 기본 템플릿 사용
                    const defaultIds = Object.keys(this.templates).slice(0, 200);
                    return defaultIds.map(id => this.templates[id]).filter(t => t !== undefined);
                }
                
                // 최종 후보 목록 반환 (실제 템플릿 객체)
                const candidates = ids.map(id => this.templates[id]).filter(t => t !== undefined);
                console.log(`최종 후보 수: ${candidates.length}`);
                return candidates;
            }
        }

        // 결과 캐싱 시스템
        class ResultCacheManager {
            constructor() {
                this.useIndexedDB = 'indexedDB' in window;
                this.db = null;
            }
            
            // 초기화
            async initialize() {
                if (!this.useIndexedDB) return;
                
                // IndexedDB 열기
                return new Promise((resolve, reject) => {
                    const request = indexedDB.open('templateCache', 1);
                    
                    request.onupgradeneeded = (e) => {
                        const db = e.target.result;
                        if (!db.objectStoreNames.contains('matches')) {
                            db.createObjectStore('matches', { keyPath: 'hash' });
                        }
                    };
                    
                    request.onsuccess = (e) => {
                        this.db = e.target.result;
                        resolve();
                    };
                    
                    request.onerror = reject;
                });
            }
            
            // 이미지 해시 생성 - 실제 구현 추가
            getImageHash(imageData) {
                if (!imageData) return 'no-image-data';
                
                // Canvas에서 축소된 이미지 생성 (8x8)
                const canvas = document.createElement('canvas');
                const ctx = canvas.getContext('2d');
                canvas.width = 8;
                canvas.height = 8;
                
                // 이미지 데이터에 따라 다른 방식으로 그리기
                if (imageData instanceof HTMLCanvasElement) {
                    ctx.drawImage(imageData, 0, 0, 8, 8);
                } else if (imageData instanceof HTMLImageElement) {
                    ctx.drawImage(imageData, 0, 0, 8, 8);
                } else if (imageData.canvas) {
                    ctx.drawImage(imageData.canvas, 0, 0, 8, 8);
                } else if (imageData.dataURL) {
                    const img = new Image();
                    img.src = imageData.dataURL;
                    ctx.drawImage(img, 0, 0, 8, 8);
                    return img.src.slice(0, 100); // 간단한 해시
                } else {
                    return 'unknown-image-type';
                }
                
                // 픽셀 데이터를 해시로 변환
                const imageData8x8 = ctx.getImageData(0, 0, 8, 8);
                let hash = '';
                
                // 64개 픽셀의 평균 계산
                let sum = 0;
                for (let i = 0; i < imageData8x8.data.length; i += 4) {
                    // 그레이스케일 값 (간단히 R 채널만 사용)
                    sum += imageData8x8.data[i];
                }
                const avg = sum / (64);
                
                // 평균보다 큰지 여부에 따라 0 또는 1 할당
                for (let i = 0; i < imageData8x8.data.length; i += 4) {
                    hash += imageData8x8.data[i] > avg ? '1' : '0';
                }
                
                return hash;
            }
            
            // 캐시에서 결과 조회
            async getCachedResult(imageData) {
                const hash = this.getImageHash(imageData);
                
                if (this.useIndexedDB) {
                    return new Promise((resolve) => {
                        const transaction = this.db.transaction(['matches'], 'readonly');
                        const store = transaction.objectStore('matches');
                        const request = store.get(hash);
                        
                        request.onsuccess = (e) => {
                            resolve(request.result ? request.result.matches : null);
                        };
                        
                        request.onerror = () => resolve(null);
                    });
                } else {
                    // LocalStorage 폴백
                    const cached = localStorage.getItem(`template_match_${hash}`);
                    return cached ? JSON.parse(cached) : null;
                }
            }
            
            // 결과 캐싱
            async cacheResult(imageData, matches) {
                // 이미지 객체 제거 (복제 불가능한 객체)
                const serializableMatches = matches.map(match => {
                    const { template, ...rest } = match;
                    // 필요한 경우 템플릿의 일부 정보만 저장
                    return {
                        ...rest,
                        templateInfo: template ? {
                            id: template.id,
                            character: template.character
                        } : null
                    };
                });
                
                const hash = this.getImageHash(imageData);
                
                if (this.useIndexedDB) {
                    const transaction = this.db.transaction(['matches'], 'readwrite');
                    const store = transaction.objectStore('matches');
                    store.put({ hash, matches: serializableMatches, timestamp: Date.now() });
                } else {
                    // LocalStorage 폴백 (용량 제한 주의)
                    try {
                        localStorage.setItem(`template_match_${hash}`, JSON.stringify(serializableMatches));
                    } catch (e) {
                        // 스토리지 한도 초과 시 가장 오래된 항목 정리
                        this.cleanupStorage();
                    }
                }
            }
            
            // 오래된 캐시 정리
            cleanupStorage() {
                // LocalStorage 항목 정리 (가장 오래된 것부터)
                try {
                    const keys = [];
                    
                    // 템플릿 매칭 관련 항목만 찾기
                    for (let i = 0; i < localStorage.length; i++) {
                        const key = localStorage.key(i);
                        if (key.startsWith('template_match_')) {
                            keys.push(key);
                        }
                    }
                    
                    // 절반은 삭제 (가장 오래된 항목들)
                    if (keys.length > 10) { // 최소 10개 이상일 때
                        // 정렬은 하지 않고 단순히 절반 삭제
                        const deleteCount = Math.floor(keys.length / 2);
                        
                        for (let i = 0; i < deleteCount; i++) {
                            localStorage.removeItem(keys[i]);
                        }
                        
                        console.log(`캐시 정리: ${deleteCount}개 항목 삭제됨`);
                    }
                } catch (e) {
                    console.error('캐시 정리 오류:', e);
                }
            }
        }

        // 새로 추가할 ParallelMatcher 클래스
        class ParallelMatcher {
            constructor(maxTime = 800) { // 기본 800ms 제한
                this.maxTime = maxTime;
            }
            
            // 워커 초기화 (실제 워커 없이 동작하는 간소화 버전)
            initialize(workerCount = 1) {
                console.log(`병렬 매칭 초기화 (최대 실행 시간: ${this.maxTime}ms)`);
            }
            
            // 타임아웃 있는 매칭 수행
            async matchWithTimeout(image, templates, threshold = 0.7) {
                console.log(`${templates.length}개 템플릿에 대한 매칭 시작 (제한 시간: ${this.maxTime}ms, 임계값: ${threshold})`);
                
                // 템플릿 우선순위 설정 (템플릿 크기 기준 정렬)
                const prioritizedTemplates = [...templates].sort((a, b) => {
                    // 크기가 비슷한 템플릿 우선순위 높임
                    const aSize = a.image ? (a.image.width * a.image.height) : 0;
                    const bSize = b.image ? (b.image.width * b.image.height) : 0;
                    const targetSize = image.width * 0.1 * image.height * 0.1; // 예상 문자 크기
                    
                    // 목표 크기와의 차이가 적을수록 우선순위 높음
                    const aDiff = Math.abs(aSize - targetSize);
                    const bDiff = Math.abs(bSize - targetSize);
                    return aDiff - bDiff;
                });
                
                return new Promise((resolve) => {
                    const results = [];
                    const startTime = performance.now();
                    
                    // 타임아웃 설정
                    const timeoutId = setTimeout(() => {
                        console.log(`${this.maxTime}ms 시간 제한 도달 - 현재까지 ${results.length}개 결과 반환`);
                        resolve(this.processBestResults(results));
                    }, this.maxTime);
                    
                    // 처리할 템플릿 수 증가 (200개 -> 500개)
                    const limitedTemplates = prioritizedTemplates.slice(0, 500);
                    console.log(`처리할 템플릿 수: ${limitedTemplates.length}`);
                    
                    // 비동기로 처리 시작 - 배치 처리 방식으로 변경
                    (async () => {
                        // 템플릿을 배치로 나누어 처리
                        const batchSize = 10; // 한 번에 10개씩 처리
                        const batches = [];
                        
                        for (let i = 0; i < limitedTemplates.length; i += batchSize) {
                            batches.push(limitedTemplates.slice(i, i + batchSize));
                        }
                        
                        for (const batch of batches) {
                            // 시간 확인
                            if (performance.now() - startTime > this.maxTime) {
                                console.log("시간 제한으로 인해 처리 중단");
                                break;
                            }
                            
                            // 배치 내 모든 템플릿을 병렬로 처리
                            const batchPromises = batch.map(template => {
                                return new Promise(async (resolveTemplate) => {
                                    try {
                                        // 임계값을 약간 낮춰서 더 많은 결과를 얻음
                                        const adjustedThreshold = threshold * 0.9; // 임계값을 10% 낮춤
                                        
                                        // 템플릿 매칭 (기존 OpenCV 함수 사용)
                                        const match = OpenCVTemplateImageCropper.findTemplateWithOpenCV(
                                            image, 
                                            template.image, 
                                            adjustedThreshold
                                        );
                                        
                                        if (match) {
                                            console.log(`매칭 성공: ${template.character || template.id}, 신뢰도: ${match.confidence}`);
                                            resolveTemplate({
                                                id: template.id,
                                                character: template.character,
                                                confidence: match.confidence,
                                                position: {
                                                    x: match.x,
                                                    y: match.y,
                                                    width: match.width,
                                                    height: match.height
                                                },
                                                template: template // 템플릿 정보 추가 (미리보기용)
                                            });
                                        } else {
                                            resolveTemplate(null);
                                        }
                                    } catch (e) {
                                        console.warn('매칭 오류:', e);
                                        resolveTemplate(null);
                                    }
                                });
                            });
                            
                            // 배치 내 모든 템플릿 처리 대기
                            const batchResults = await Promise.all(batchPromises);
                            
                            // 유효한 결과만 추가
                            batchResults.filter(r => r !== null).forEach(r => results.push(r));
                            
                            // UI 갱신을 위한 약간의 대기
                            await new Promise(r => setTimeout(r, 0));
                        }
                        
                        // 모든 처리 완료
                        clearTimeout(timeoutId);
                        console.log(`매칭 처리 완료: ${results.length}개 결과`);
                        
                        // 결과가 없으면 임계값을 매우 낮춰서 다시 시도
                        if (results.length === 0 && limitedTemplates.length > 0) {
                            console.log("결과가 없어 임계값을 낮춰서 다시 시도");
                            const veryLowThreshold = 0.4; // 매우 낮은 임계값
                            
                            // 처음 50개 템플릿만 사용하여 다시 시도
                            const retryPromises = limitedTemplates.slice(0, 50).map(template => {
                                return new Promise(async (resolveRetry) => {
                                    try {
                                        const match = OpenCVTemplateImageCropper.findTemplateWithOpenCV(
                                            image, 
                                            template.image, 
                                            veryLowThreshold
                                        );
                                        
                                        if (match) {
                                            console.log(`낮은 임계값 매칭: ${template.character || template.id}, 신뢰도: ${match.confidence}`);
                                            resolveRetry({
                                                id: template.id,
                                                character: template.character,
                                                confidence: match.confidence,
                                                position: {
                                                    x: match.x,
                                                    y: match.y,
                                                    width: match.width,
                                                    height: match.height
                                                },
                                                template: template
                                            });
                                        } else {
                                            resolveRetry(null);
                                        }
                                    } catch (e) {
                                        console.warn('재시도 매칭 오류:', e);
                                        resolveRetry(null);
                                    }
                                });
                            });
                            
                            const retryResults = await Promise.all(retryPromises);
                            retryResults.filter(r => r !== null).forEach(r => results.push(r));
                        }
                        
                        resolve(this.processBestResults(results));
                    })();
                });
            }
            
            // 최고 결과 처리
            processBestResults(allResults) {
                // 결과를 신뢰도 기준으로 정렬하고 상위 결과 반환
                return allResults
                    .sort((a, b) => b.confidence - a.confidence)
                    .slice(0, 20); // 상위 20개 결과
            }
        }

        // DOM 요소
        const statusEl = document.getElementById('status');
        const initButton = document.getElementById('initButton');
        const captureButton = document.getElementById('captureButton');
        const modeSelector = document.getElementById('modeSelector');
        const resultContainer = document.getElementById('resultContainer');
        const comparisonContainer = document.getElementById('comparisonContainer');
        const resultTabs = document.getElementById('resultTabs');
        const tabs = document.querySelectorAll('.tab');
        const charRecognitionSection = document.getElementById('charRecognitionSection');
        const templateLoadingStatus = document.getElementById('templateLoadingStatus');
        const thresholdSlider = document.getElementById('thresholdSlider');
        const thresholdValue = document.getElementById('thresholdValue');
        const loadTemplatesButton = document.getElementById('loadTemplatesButton');
        const recognizeButton = document.getElementById('recognizeButton');
        const recognitionResultContainer = document.getElementById('recognitionResultContainer');
        const wasmToggle = document.getElementById('wasmToggle');
        const performanceResult = document.getElementById('performanceResult');

        let isTemplatesLoaded = false;
        let lastCroppedResult = null;

        // 추가: 캐시 매니저 초기화
        let cacheManager = null;

        // 결과 저장소 (모드별 비교용)
        const resultStore = {
            default: null,
            mode1: null
        };
        
        // 상태 업데이트 함수
        function updateStatus(message, type = 'info') {
            statusEl.textContent = message;
            statusEl.className = 'status';
            if (type === 'error') statusEl.classList.add('error');
            if (type === 'success') statusEl.classList.add('success');
        }
        
        // 초기화 정보 - 실제 템플릿 및 크롭 영역 설정
        const initOptions = {
            debug: true,
            opencvPath: 'https://docs.opencv.org/4.7.0/opencv.js',
            modes: ['default', 'mode1'],
            defaultMode: 'default',
            templates: {
                'nickname': {
                    url: './core/template.PNG',
                    // 기본 모드 (신청자 목록)
                    cropRegion: {
                        offsetX: 3,
                        offsetY: -550,
                        width: 230,
                        height: 330
                    },
                    // 모드 1 (공대원 목록)
                    cropRegion_mode1: {
                        offsetX: 4,
                        offsetY: -530,
                        width: 520,
                        height: 310
                    }
                }
            }
        };
        
        // 모듈 초기화 함수
        async function initializeModule() {
            updateStatus('모듈 초기화 중...');
            initButton.disabled = true;
            initButton.innerHTML = '초기화 중... <span class="loading">로드 중...</span>';
            
            try {
                // 기존 JS 기반 모듈 초기화
                const jsSuccess = await OpenCVTemplateImageCropper.initialize(initOptions);
                
                // WASM 모듈 초기화
                wasmMatcher = new WasmTemplateMatcher();
                const wasmSuccess = await wasmMatcher.initialize();
                
                // 추가: 캐시 매니저 초기화
                cacheManager = new ResultCacheManager();
                await cacheManager.initialize();
                
                if (jsSuccess && wasmSuccess) {
                    updateStatus('JavaScript 및 WASM 모듈 초기화 완료', 'success');
                    captureButton.disabled = false;
                    initButton.textContent = '초기화 완료';
                    
                    // WASM 토글 표시
                    wasmToggle.style.display = 'block';
                    
                    // 모드 선택기 표시
                    modeSelector.style.display = 'block';
                    
                    // 초기 모드 설정
                    const defaultModeRadio = document.querySelector('input[name="matchMode"][value="default"]');
                    defaultModeRadio.checked = true;
                    OpenCVTemplateImageCropper.setMode('default');
                    
                    // 모드 변경 이벤트 등록
                    setupModeChangeListeners();
                } else {
                    updateStatus('모듈 초기화 실패', 'error');
                    initButton.disabled = false;
                    initButton.textContent = '초기화 재시도';
                }
            } catch (error) {
                updateStatus(`초기화 오류: ${error.message}`, 'error');
                console.error('초기화 오류:', error);
                initButton.disabled = false;
                initButton.textContent = '초기화 재시도';
            }
        }
        
        // 모드 변경 이벤트 리스너 설정
        function setupModeChangeListeners() {
            const modeRadios = document.querySelectorAll('input[name="matchMode"]');
            modeRadios.forEach(radio => {
                radio.addEventListener('change', (e) => {
                    const mode = e.target.value;
                    OpenCVTemplateImageCropper.setMode(mode);
                    updateStatus(`매칭 모드가 '${mode}'(으)로 변경되었습니다.`);
                });
            });
        }
        
        // 탭 전환 기능 설정
        function setupTabListeners() {
            tabs.forEach(tab => {
                tab.addEventListener('click', () => {
                    // 모든 탭 비활성화
                    tabs.forEach(t => t.classList.remove('active'));
                    // 클릭된 탭 활성화
                    tab.classList.add('active');
                    
                    // 컨테이너 전환
                    const target = tab.dataset.target;
                    if (target === 'latestResult') {
                        resultContainer.style.display = 'block';
                        comparisonContainer.style.display = 'none';
                    } else if (target === 'modeComparison') {
                        resultContainer.style.display = 'none';
                        comparisonContainer.style.display = 'block';
                        updateComparisonView();
                    }
                });
            });
        }
        
        // 비교 보기 업데이트
        function updateComparisonView() {
            comparisonContainer.innerHTML = '';
            
            const hasModeResults = Object.values(resultStore).some(result => result !== null);
            
            if (!hasModeResults) {
                const noResults = document.createElement('div');
                noResults.className = 'status';
                noResults.textContent = '아직 각 모드별 결과가 없습니다. 각 모드에서 분석을 실행해주세요.';
                comparisonContainer.appendChild(noResults);
                return;
            }
            
            // 모드별 결과 표시
            for (const [mode, result] of Object.entries(resultStore)) {
                if (result === null) continue;
                
                const modeResultContainer = document.createElement('div');
                modeResultContainer.style.marginBottom = '30px';
                modeResultContainer.style.borderBottom = '1px solid #eee';
                modeResultContainer.style.paddingBottom = '20px';
                
                const modeTitle = document.createElement('h3');
                modeTitle.textContent = `${mode === 'default' ? '신청자 목록' : '공대원 목록'} 결과`;
                modeResultContainer.appendChild(modeTitle);
                
                const debugView = OpenCVTemplateImageCropper.createDebugView(result);
                modeResultContainer.appendChild(debugView);
                
                comparisonContainer.appendChild(modeResultContainer);
            }
        }
        
        // 클립보드 이미지 분석 함수
        async function analyzeClipboardImage() {
            resultContainer.innerHTML = '';
            recognitionResultContainer.innerHTML = '';
            recognitionResultContainer.style.display = 'none';
            resultTabs.style.display = 'none';
            charRecognitionSection.style.display = 'none';
            
            const currentMode = document.querySelector('input[name="matchMode"]:checked').value;
            updateStatus(`${currentMode} 모드로 클립보드 이미지 분석 중...`);
            captureButton.disabled = true;
            
            // 시작 시간 기록 (성능 측정)
            const startTime = performance.now();
            
            try {
                let result;
                
                if (useWasm) {
                    // WASM 버전 사용
                    // 먼저 클립보드 이미지 가져오기
                    const clipboardImage = await OpenCVTemplateImageCropper.getImageFromClipboard();
                    
                    // 템플릿 이미지 로드 (기존 모듈 사용)
                    const templateKey = 'nickname';
                    const templateImage = OpenCVTemplateImageCropper.templates[templateKey];
                    
                    // WASM 모듈로 템플릿 매칭 수행
                    const match = await wasmMatcher.findTemplateWithOpenCV(
                        clipboardImage, 
                        templateImage, 
                        0.7 // 임계값
                    );
                    
                    if (!match) {
                        throw new Error('템플릿 매칭 실패: 이미지에서 템플릿을 찾을 수 없습니다.');
                    }
                    
                    // 현재 모드에 따른 크롭 영역 계산
                    const cropConfig = initOptions.templates[templateKey][
                        currentMode === 'default' ? 'cropRegion' : `cropRegion_${currentMode}`
                    ];
                    
                    // 크롭 영역 계산
                    const cropRegion = {
                        x: Math.max(0, match.x + cropConfig.offsetX),
                        y: Math.max(0, match.y + cropConfig.offsetY),
                        width: cropConfig.width,
                        height: cropConfig.height
                    };
                    
                    // WASM 모듈로 이미지 크롭
                    result = await wasmMatcher.cropImageRegion(
                        clipboardImage, 
                        cropRegion.x, 
                        cropRegion.y, 
                        cropRegion.width, 
                        cropRegion.height
                    );
                } else {
                    // 기존 JS 버전 사용
                    result = await OpenCVTemplateImageCropper.cropFromClipboard('nickname');
                }
                
                // 종료 시간 기록 (성능 측정)
                const endTime = performance.now();
                const executionTime = endTime - startTime;
                
                // 성능 정보 표시
                performanceResult.innerHTML = `
                    <div class="info-box">
                        <p><strong>성능 측정:</strong> ${executionTime.toFixed(2)}ms (${useWasm ? 'WebAssembly' : 'JavaScript'})</p>
                    </div>
                `;
                performanceResult.style.display = 'block';
                
                // 결과 저장 (모드별 비교용)
                resultStore[currentMode] = result;
                lastCroppedResult = result;
                
                // 결과 표시
                updateStatus(`이미지 분석 완료 (${currentMode} 모드)`, 'success');
                
                // 디버그 뷰 추가
                const debugView = OpenCVTemplateImageCropper.createDebugView(result);
                resultContainer.appendChild(debugView);
                
                // 탭 표시 활성화
                resultTabs.style.display = 'flex';
                setupTabListeners();

                // 문자 인식 섹션 표시
                charRecognitionSection.style.display = 'block';
                loadTemplatesButton.disabled = false;
                
                captureButton.disabled = false;
            } catch (error) {
                updateStatus(`분석 오류: ${error.message}`, 'error');
                console.error('분석 오류:', error);
                
                // 오류 정보 추가
                const errorInfo = document.createElement('div');
                errorInfo.className = 'error';
                errorInfo.style.padding = '10px';
                errorInfo.style.marginTop = '10px';
                
                errorInfo.innerHTML = `
                    <h4>오류 발생</h4>
                    <p>${error.message}</p>
                    <p>가능한 해결 방법:</p>
                    <ul>
                        <li>클립보드에 이미지가 있는지 확인하세요.</li>
                        <li>이미지에 템플릿과 일치하는 부분이 있는지 확인하세요.</li>
                        <li>templates 폴더에 템플릿 이미지가 있는지 확인하세요.</li>
                    </ul>
                `;
                
                resultContainer.appendChild(errorInfo);
                captureButton.disabled = false;
            }
        }
        
        // 이벤트 리스너 등록
        initButton.addEventListener('click', initializeModule);
        captureButton.addEventListener('click', analyzeClipboardImage);

        // 임계값 슬라이더 이벤트
        thresholdSlider.addEventListener('input', (e) => {
            const value = e.target.value / 100;
            thresholdValue.textContent = value.toFixed(2);
        });

        // 템플릿 로드 버튼 이벤트
        loadTemplatesButton.addEventListener('click', async () => {
            await loadCharacterTemplates();
        });

        // 문자 인식 버튼 이벤트
        recognizeButton.addEventListener('click', async () => {
            await recognizeCharactersAdvanced();
        });

        // 문자 템플릿 로드 함수
        async function loadCharacterTemplates() {
            templateLoadingStatus.style.display = 'block';
            templateLoadingStatus.textContent = '문자 템플릿 로드 중...';
            loadTemplatesButton.disabled = true;
            
            try {
                // 문자 매핑 데이터 로드 - baseImagePath를 빈 문자열로 변경
                const mappingSuccess = await OpenCVTemplateImageCropper.loadCharacterMapping('./character_mapping.json', '');
                
                if (!mappingSuccess) {
                    throw new Error('문자 매핑 데이터 로드 실패');
                }
                
                // 문자 템플릿 이미지 로드 (진행상황 콜백 포함)
                const loadedCount = await OpenCVTemplateImageCropper.loadCharacterTemplates(50, (progress) => {
                    templateLoadingStatus.textContent = `문자 템플릿 로드 중: ${progress.loaded}/${progress.total} (${progress.progress.toFixed(1)}%)`;
                });
                
                // 새로 추가: 인덱서 및 병렬 매처 초기화
                indexer = new TemplateIndexer();
                indexer.buildIndex(OpenCVTemplateImageCropper.characterTemplates);
                
                parallelMatcher = new ParallelMatcher(800); // 800ms 제한
                parallelMatcher.initialize();
                
                templateLoadingStatus.className = 'status success';
                templateLoadingStatus.textContent = `템플릿 로드 완료: ${loadedCount}개 문자 템플릿`;
                
                isTemplatesLoaded = true;
                recognizeButton.disabled = false;
            } catch (error) {
                templateLoadingStatus.className = 'status error';
                templateLoadingStatus.textContent = `템플릿 로드 오류: ${error.message}`;
                loadTemplatesButton.disabled = false;
            }
        }

        // 인터페이스 함수
        async function recognizeCharactersAdvanced() {
            if (!lastCroppedResult) {
                updateStatus('먼저 이미지를 크롭해야 합니다.', 'error');
                return;
            }
            
            if (!isTemplatesLoaded) {
                updateStatus('먼저 문자 템플릿을 로드해야 합니다.', 'error');
                return;
            }
            
            // indexer, parallelMatcher, cacheManager가 모두 초기화 되었는지 확인
            if (!indexer || !parallelMatcher || !cacheManager) {
                updateStatus('매칭 시스템이 초기화되지 않았습니다. 문자 템플릿을 다시 로드해주세요.', 'error');
                return;
            }
            
            recognitionResultContainer.innerHTML = '';
            recognizeButton.disabled = true;
            recognizeButton.textContent = '문자 인식 중...';
            
            try {
                // 슬라이더에서 임계값 가져오기
                const threshold = thresholdSlider.value / 100;
                
                // 이미지 준비
                const image = lastCroppedResult.canvas || await createImageFromDataURL(lastCroppedResult.dataURL);
                
                // 진행 상황 표시 요소
                const progressDiv = document.createElement('div');
                progressDiv.className = 'status';
                progressDiv.textContent = '최적화된 문자 인식 준비 중...';
                recognitionResultContainer.style.display = 'block';
                recognitionResultContainer.appendChild(progressDiv);
                
                // 시작 시간 기록 (성능 측정)
                const startTime = performance.now();
                
                // 1. 캐시 확인
                const cachedResult = await cacheManager.getCachedResult(lastCroppedResult);
                
                let results;
                if (cachedResult) {
                    progressDiv.textContent = '캐시된 결과 사용 중...';
                    console.log('캐시에서 결과를 불러왔습니다.');
                    results = cachedResult;
                } else {
                    // 2. 템플릿 인덱싱으로 후보 추출
                    progressDiv.textContent = '템플릿 인덱싱으로 후보 추출 중...';
                    
                    // 템플릿 개수 출력
                    console.log(`인덱서에 등록된 템플릿 수: ${Object.keys(indexer.templates).length}`);
                    
                    const candidates = indexer.findCandidates(image);
                    console.log(`인덱싱 후 후보 템플릿 수: ${candidates.length}`);
                    progressDiv.textContent = `인덱싱으로 ${candidates.length}개 후보 추출 완료`;
                    
                    // 후보가 없는 경우 원인 로깅
                    if (candidates.length === 0) {
                        console.log('후보 추출 실패 원인 분석:');
                        console.log('- 인덱서 버킷 수:', Object.keys(indexer.index).length);
                        // 이미지에서 추출한 특징 로깅
                        const features = indexer.extractSimpleFeatures(image);
                        console.log('- 쿼리 이미지 특징:', features);
                        console.log('- 양자화된 값:', features.map(f => indexer.quantizeFeature(f)));
                    }
                    
                    // 3. 병렬 매칭으로 정밀 분석
                    progressDiv.textContent = '병렬 매칭으로 정밀 분석 중...';
                    results = await parallelMatcher.matchWithTimeout(image, candidates, threshold);
                    console.log(`병렬 매칭 결과 수: ${results.length}`);
                    
                    // 4. 결과 캐싱
                    await cacheManager.cacheResult(lastCroppedResult, results);
                }
                
                // 종료 시간 기록
                const endTime = performance.now();
                const executionTime = endTime - startTime;
                
                // 결과 표시
                progressDiv.textContent = `문자 인식 완료: ${results.length}개 매칭됨 (${executionTime.toFixed(0)}ms)`;
                
                // 매칭 결과 표시
                displayRecognitionResults(results);
                
                updateStatus(`문자 인식 완료: ${results.length}개 매칭됨 (${executionTime.toFixed(0)}ms)`, 'success');
            } catch (error) {
                console.error('문자 인식 오류:', error);
                updateStatus(`문자 인식 오류: ${error.message}`, 'error');
            } finally {
                recognizeButton.disabled = false;
                recognizeButton.textContent = '문자 인식 실행';
            }
        }

        // 인식 결과 표시 함수 (새로 추가)
        function displayRecognitionResults(results) {
            // 결과 컨테이너 비우기
            const container = document.getElementById('recognitionResultContainer');
            
            if (!results || results.length === 0) {
                // 결과가 없는 경우
                const noResults = document.createElement('div');
                noResults.className = 'status error';
                noResults.textContent = '매칭된 문자가 없습니다. 다른 이미지를 시도하거나 임계값을 낮춰보세요.';
                container.appendChild(noResults);
                
                // 디버그 정보 추가
                const debugInfo = document.createElement('div');
                debugInfo.className = 'info-box';
                debugInfo.innerHTML = `
                    <h4>문제 해결 가이드:</h4>
                    <ul>
                        <li>임계값을 낮춰보세요 (현재: ${thresholdSlider.value/100})</li>
                        <li>이미지가 선명한지 확인하세요</li>
                        <li>크롭된 영역에 텍스트가 포함되어 있는지 확인하세요</li>
                        <li>브라우저 콘솔(F12)에서 디버그 정보를 확인하세요</li>
                    </ul>
                    <p>임계값을 0.5 이하로 낮추고 다시 시도해보세요.</p>
                `;
                container.appendChild(debugInfo);
                return;
            }
            
            // 결과 테이블 생성
            const resultTable = document.createElement('table');
            resultTable.style.width = '100%';
            resultTable.style.borderCollapse = 'collapse';
            resultTable.style.marginTop = '15px';
            
            // 테이블 헤더
            const headerRow = document.createElement('tr');
            ['문자', '신뢰도', '위치 (x, y)', '미리보기'].forEach(text => {
                const th = document.createElement('th');
                th.textContent = text;
                th.style.padding = '8px';
                th.style.backgroundColor = '#f2f2f2';
                th.style.borderBottom = '1px solid #ddd';
                headerRow.appendChild(th);
            });
            resultTable.appendChild(headerRow);
            
            // 결과 행 추가
            results.forEach(result => {
                const row = document.createElement('tr');
                
                // 문자
                const charCell = document.createElement('td');
                charCell.textContent = result.character || (result.templateInfo ? result.templateInfo.character : '?');
                charCell.style.padding = '8px';
                charCell.style.textAlign = 'center';
                charCell.style.fontSize = '18px';
                charCell.style.fontWeight = 'bold';
                row.appendChild(charCell);
                
                // 신뢰도
                const confCell = document.createElement('td');
                confCell.textContent = (result.confidence * 100).toFixed(1) + '%';
                confCell.style.padding = '8px';
                confCell.style.textAlign = 'center';
                row.appendChild(confCell);
                
                // 위치
                const posCell = document.createElement('td');
                posCell.textContent = `(${result.position.x}, ${result.position.y})`;
                posCell.style.padding = '8px';
                posCell.style.textAlign = 'center';
                row.appendChild(posCell);
                
                // 미리보기 (시각적 표현)
                const previewCell = document.createElement('td');
                previewCell.style.padding = '8px';
                previewCell.style.textAlign = 'center';
                
                // 미리보기를 위한 캔버스 생성 (실제 이미지 데이터가 있을 경우)
                if (result.template && result.template.image) {
                    const previewCanvas = document.createElement('canvas');
                    previewCanvas.width = 32;
                    previewCanvas.height = 32;
                    const ctx = previewCanvas.getContext('2d');
                    ctx.drawImage(result.template.image, 0, 0, 32, 32);
                    previewCell.appendChild(previewCanvas);
                } else {
                    // 캐시된 결과의 경우 템플릿 이미지가 없으므로 문자 정보만 표시
                    const charDisplay = document.createElement('div');
                    charDisplay.textContent = result.character || (result.templateInfo ? result.templateInfo.character : '?');
                    charDisplay.style.fontSize = '20px';
                    charDisplay.style.fontWeight = 'bold';
                    previewCell.appendChild(charDisplay);
                }
                
                row.appendChild(previewCell);
                resultTable.appendChild(row);
            });
            
            container.appendChild(resultTable);
            
            // 요약 정보
            const summary = document.createElement('div');
            summary.className = 'info-box';
            summary.innerHTML = `
                <p><strong>인식 결과 요약:</strong> 총 ${results.length}개의 문자를 인식했습니다.</p>
                <p>평균 신뢰도: ${(results.reduce((sum, r) => sum + r.confidence, 0) / results.length * 100).toFixed(1)}%</p>
            `;
            container.appendChild(summary);
        }
        
        // 이미지 데이터 URL을 이미지 객체로 변환하는 유틸리티 함수 (새로 추가)
        function createImageFromDataURL(dataURL) {
            return new Promise((resolve, reject) => {
                const img = new Image();
                img.onload = () => resolve(img);
                img.onerror = () => reject(new Error('이미지 데이터 로드 실패'));
                img.src = dataURL;
            });
        }

        // WASM 토글 이벤트 리스너
        wasmToggle.addEventListener('change', function() {
            useWasm = this.checked;
            updateStatus(`템플릿 매칭 엔진: ${useWasm ? 'WebAssembly' : 'JavaScript'}`, 'info');
        });
    </script>
</body>
</html>